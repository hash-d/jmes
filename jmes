#!/usr/bin/env python

import jmespath
import sys
import json
import yaml
import getopt
import tempfile
import subprocess
from pprint import pprint


def usage():
    print("""
usage: jmes [-yYjJh] [ JMES-Expression [ /path/to/file ] ]

    -j  consider input as JSON
    -J  emit output as JSON
    -y  consider input as YAML
    -Y  emit output as YAML

    -h  this help screen

If no -j or -y given, the script will try to guess the file's format, first by
its filename, then by its contents (first byte is checked for being [ or { and
considered to be JSON, otherwise YAML)

If a JMES-Expression is not given, it is assumed to be "@", which returns the
input as-is.  Use it to transform from JSON to YAML and the other way around,
or to just run 'jq -C | less -r' and get a color, pretty- printed output on
less.

To transform a file from one format to the other:

cat file_path | jmes -jY 
cat file_path | jmes -yJ

or

jmes -jY "@" file_path
jmes -yJ "@" file_path

Here "@" stands for JMESPath "current-node", and just passes its input to the
output.
""", file=sys.stderr)


opts, args = getopt.getopt(sys.argv[1:], "hyjYJ")

# input and output formats (json or yaml)
in_f = ""
out_f = ""
filename = ""

for o, a in opts:
    if o == "-y":
        in_f = "yaml"
    elif o == "-Y":
        out_f = "yaml"
    elif o == "-j":
        in_f = "json"
    elif o == "-J":
        out_f = "json"
    elif o == "-h":
        usage()
        sys.exit(0)
    else:
        print(f"jmes: unknown option {o}", file=sys.stderr)
        usage()
        sys.exit(1)

if len(args) > 2:
    usage()
    sys.exit(1)

try:
    expression = args[0]
except IndexError:
    expression = "@"

# Get thetext
try:
    filename = args[1]
    if filename == "-":
        text = sys.stdin.read()
    else:
        with open(filename) as f:
            text = f.read()
except IndexError:
    text = sys.stdin.read()

# Guess the input format, if not given
# TODO: if not provided, what about trying one, then the other, like Ansible does?
if in_f == "":
    print(f"You didn't tell me what kind of file it is; I'll try to guess", file=sys.stderr)
    if filename.lower().endswith(".yaml") or filename.lower().endswith("yml"):
        in_f = "yaml"
        how = "from the file extension"
    elif filename.lower().endswith(".json"):
        in_f = "json"
        how = "from the file extension"
    elif text[0] in ["{", "["]:
        in_f = "json"
        how = "from the first character"
    else:
        in_f = "yaml"
        how = "as a fallback"
    print(f"I guessed {in_f} {how}", file=sys.stderr)

# If not specifically requested, we output in the same format as the input
if out_f == "":
    out_f = in_f

if in_f == "json":
    data = json.loads(text)
elif in_f == "yaml":
    data = yaml.safe_load(text)
else:
    raise Exception("This should not have happened")

result = jmespath.search(expression, data)

out_file = sys.stdout

if out_f == "json":
    out_content = json.dumps(result, indent=2)
elif out_f == "yaml":
    out_content = yaml.dump(result)
else:
    raise Exception("This should not have happened")

if sys.stdout.isatty():
    with tempfile.NamedTemporaryFile("w") as out:
        # print(out_content, file=out)
        out.write(out_content)
        out.flush()
        if out_f == "json":
            p = subprocess.Popen(f"jq -C . {out.name} | less -r", shell=True)
        elif out_f == "yaml":
            p = subprocess.Popen(f"less {out.name}", shell=True)
        p.wait()
else:
    print(out_content)
